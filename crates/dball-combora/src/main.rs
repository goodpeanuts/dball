fn main() -> anyhow::Result<()> {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Debug)
        .init();

    log::info!("Running in terminal mode with concurrent batch generation (10 threads).");
    use dball_combora::dball::DBallBatch;
    use dball_combora::generator::RandomGenerator as _;
    use std::sync::mpsc;
    use std::sync::{Arc, Mutex};
    use std::thread;

    const THREAD_COUNT: usize = 8;

    // Create a channel to receive results from threads
    let (tx, rx) = mpsc::channel();
    let result_found = Arc::new(Mutex::new(false));

    // Spawn 10 threads to generate batches concurrently
    for i in 0..THREAD_COUNT {
        let tx_clone = tx.clone();
        let result_found_clone = Arc::clone(&result_found);

        thread::spawn(move || {
            log::debug!("Thread {} starting batch generation", i);

            // Continuously try to generate batch until one is found or another thread succeeds
            loop {
                // Check if another thread already found a result
                {
                    let found = result_found_clone.lock().unwrap();
                    if *found {
                        log::debug!(
                            "Thread {} exiting - result already found by another thread",
                            i
                        );
                        return;
                    }
                }

                match dball_combora::dball::DBall::generate_batch() {
                    Ok(tickets) => {
                        // Mark that we found a result
                        {
                            let mut found = result_found_clone.lock().unwrap();
                            if !*found {
                                *found = true;
                                log::info!("Thread {} successfully generated batch first!", i);
                                // Send the result
                                let _ = tx_clone.send((i, tickets));
                                return;
                            } else {
                                // Another thread already found a result
                                log::debug!(
                                    "Thread {} generated batch but another thread was first",
                                    i
                                );
                                return;
                            }
                        }
                    }
                    Err(e) => {
                        log::debug!("Thread {} failed to generate batch, retrying: {}", i, e);
                        // Continue the loop to try again
                    }
                }
            }
        });
    }

    // Drop the original sender so rx.recv() can detect when all threads are done
    drop(tx);

    // Wait for the first successful result
    match rx.recv() {
        Ok((thread_id, tickets)) => {
            log::info!("First successful batch generated by thread {}", thread_id);
            log::info!("Generated tickets:\n{}", DBallBatch(tickets.to_vec()));

            // Signal other threads to stop
            {
                let mut found = result_found.lock().unwrap();
                *found = true;
            }

            log::info!(
                "Batch generation completed successfully. Other threads will stop automatically."
            );
            Ok(())
        }
        Err(_) => {
            // All threads finished without success
            log::error!("All threads failed to generate a batch");
            Err(anyhow::anyhow!("All batch generation attempts failed"))
        }
    }
}
